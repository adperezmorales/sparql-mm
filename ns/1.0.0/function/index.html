<html><head><link rel="stylesheet" type="text/css" href="style.css"></head><body>
<h1>SPARQL-MM Function Library for Media Fragments</h1>

<p>
The URI for this vocabulary is <code>http://linkedmultimedia.org/sparql-mm/ns/1.0.0/function#</code>. When abbreviating terms the suggested prefix is <code>mf</code>. Each function in this function set has a URI constructed by appending a term name to the vocabulary URI. For example <code>http://linkedmultimedia.org/sparql-mm/ns/1.0.0/function#after</code>. There are machine readable function description using <a href="http://www.ldodds.com/schemas/sparql-extension-description/">SPARQL Extension Description Vocabulary]</a> in <a href="index.rdf">RDF/XML</a> and <a href="index.ttl">TURTLE</a>.</p>
<h2>Spatial Relations</h2><table>
<tr><th>Relation name</th><th>Description</th>
<tr><td>mf:bottom( *resource1*, *resource2* )</td><td>returns true if resource.y >= 50%.</td>
<tr><td>mf:isAbove( *resource1*, *resource2* )</td><td>returns true if resource1.y + resource1.h <= resource2.y, else false.</td>
<tr><td>mf:isBelow( *resource1*, *resource2* )</td><td>returns true if resource2.y + resource2.h <= resource1.y, else false.</td>
<tr><td>mf:left( *resource1*, *resource2* )</td><td>returns true if resource.x + resource.w <= 50%.</td>
<tr><td>mf:leftBeside( *resource1*, *resource2* )</td><td>returns true if resource1.x + resource1.w <= resource2.x, else false.</td>
<tr><td>mf:right( *resource1*, *resource2* )</td><td>returns true if resource.x >= 50%.</td>
<tr><td>mf:rightBeside( *resource1*, *resource2* )</td><td>returns true if resource2.x + resource2.w <= resource1.x, else false.</td>
<tr><td>mf:spatialCovers( *resource1*, *resource2* )</td><td>returns true if all points of resource1.box are points of resource2.box, else false. </td>
<tr><td>mf:spatialDisjoint( *resource1*, *resource2* )</td><td>returns true is resource1.box has no common points with resource2.box, else false.</td>
<tr><td>mf:spatialEqual( *resource1*, *resource2* )</td><td>returns true if resource1.box == resource2.box, else false.</td>
<tr><td>mf:spatialIntersects( *resource1*, *resource2* )</td><td>returns true if resource1.box has at least one common point with resource2.box, else false.</td>
<tr><td>mf:spatialTouches( *resource1*, *resource2* )</td><td>returns true if resource1.box.edge has at least one common point with resource2.box.edge and resource1.box.interior has no common point with resource2.box.interior, else false.</td>
<tr><td>mf:top( *resource1*, *resource2* )</td><td>returns true if resource.y + resource.h <= 50%.</td>
</table>
<h2>Spatial Aggregations</h2><table>
<tr><th>Relation name</th><th>Description</th>
<tr><td>mf:spatialBoundingBox( *resource1*, *resource2* )</td><td>returns new MediaFragmentURI with spatial fragment out of existing resources A and B, so that x = min( A.x, B.x ) and y = min( A.y, B.y ) and w = max( A.x + A.w, B.x + B.w ) and h = max( A.y + A.h, B.y + B.h ).</td>
<tr><td>mf:spatialIntersection( *resource1*, *resource2* )</td><td>returns new MediaFragmentURI with spatial fragment out of existing resources A and B, so that x = max( A.x, B.x ) and y = max( A.y, B.y ) and w = min( A.x + A.w, B.x + B.w ) - max( A.x, B.x ) and h = min( A.y + A.h, B.y + B.h ) - max( A.y, A.x )</td>
</table>
<h2>Temporal Relations</h2><table>
<tr><th>Relation name</th><th>Description</th>
<tr><td>mf:after( *resource1*, *resource2* )</td><td>returns *true* if resource1.start >= resource2.end, else *false*.</td>
<tr><td>mf:before( *resource1*, *resource2* )</td><td>returns true if resource1.end <= resource2.start, else false.</td>
<tr><td>mf:finishes( *resource1*, *resource2* )</td><td>returns true if resource1.end == resource2.end and resource1.start > resource1.start , else false.</td>
<tr><td>mf:temporalMeets( *resource1*, *resource2* )</td><td>returns true if resource1.start = resource2.end or resource1.end = resource2.start, else false.</td>
<tr><td>mf:starts( *resource1*, *resource2* )</td><td>returns true if resource1.start == resource2.start and resource1.end < resource2.end , else false.</td>
<tr><td>mf:temporalContains( *resource1*, *resource2* )</td><td>returns true if resource1.start <= resource2.start and resource1.end >= resource2.end, else false.</td>
<tr><td>mf:temporalEqual( *resource1*, *resource2* )</td><td>returns true if resource1.start == resource2.start and resource1.end == resource2.end, else false.</td>
<tr><td>mf:temporalOverlaps( *resource1*, *resource2* )</td><td>returns true if resource1.start < resource2.start < resource1.end < resource2.end or resource2.start < resource1.start < resource2.end < resource1.end, else false.</td>
</table>
<h2>Temporal Aggregations</h2><table>
<tr><th>Relation name</th><th>Description</th>
<tr><td>mf:temporalBoundingBox( *resource1*, *resource2* )</td><td>returns new MediaFragmentURI with temporal fragment ( Min( resource1.start, resource2.start ), Max( resource1.end, resource2.end ) ).</td>
<tr><td>mf:temporalIntermediate( *resource1*, *resource2* )</td><td>returns new MediaFragmentURI with temporal fragment ( Min( resource1.end, resource2.end ), Max( resource1.start, resource2.start ) ) if intersection not exists, else null.</td>
<tr><td>mf:temporalIntersection( *resource1*, *resource2* )</td><td>returns new MediaFragmentURI with temporal fragment ( Max( resource1.start, resource2.start ), Min( resource1.end, resource2.end ) ) if intersection exists, else null.</td>
</table>
<h2>Combined Relations</h2><table>
<tr><th>Relation name</th><th>Description</th>
</table>
<h2>Combined Aggregations</h2><table>
<tr><th>Relation name</th><th>Description</th>
<tr><td>mf:boundingBox( *resource1*, *resource2* )</td><td>returns new MediaFragmentURI with spatial and temporal fragment. It it works like spatialFunction:boundingBox, temporalFunction:boundingBox or both together.</td>
<tr><td>mf:intersection( *resource1*, *resource2* )</td><td>returns new MediaFragmentURI with spatial and temporal fragment. It works like spatialFunction:boundingBox, temporalFunction:intersection and both.</td>
</table>
